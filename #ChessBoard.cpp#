/* Implementation file for ChessBoard class  */
#include <iostream> //is this necessary?
#include "ChessBoard.h"
#include "ChessPiece.h"

using std::cout;
using std::endl;

ChessBoard::ChessBoard(){}

void ChessBoard::loadState(const char* fenRecord){

  int index = 0, row = 0, col = 0;

  // loop through fen string until space (denotes we've passed the last square on the board)
  while (fenRecord[index] != ' '){

    // if you hit an end of row marker (/), reset the col value to 0 and increment the row value
    if (fenRecord[index] == '/'){
      index++;
      row++;
      col = 0;
    }

    // if you hit 1-8, determine the number of blank spaces to insert
    if (fenRecord[index] >= '1' && fenRecord[index] <= '8'){

      
      // save number of blank spaces to insert into a variable
      int blankSpaceNeeded;
      blankSpaceNeeded = (fenRecord[index] - '0');

      // index to use in while loop
      int blankSpaceIndex = 0;

      // cout << fenRecord[index] << "  " << blankSpaceNeeded << endl;

      // insert a null pointer (representing an empty space) into pointer array (the board)
      while (blankSpaceIndex <= blankSpaceNeeded){
        boardLayout[row][col] = nullptr;
        blankSpaceIndex++;
        col++;
      }
      
      //index (just once for the char)
      index++;
    }
    

    else {
      char currentFenChar = fenRecord[index];
      ChessPiece* ptr = pieceIdentifier(currentFenChar);
      boardLayout[row][col] = ptr;
      index++;
      col++;
    }
  }
        
  //move the index by 1 to reach the w/b character
  index++;
  char startingColor;
  if (fenRecord[index] == 'w'){
    startingColor = 'w';
  }
  if (fenRecord[index] == 'b'){
    startingColor = 'b';
  }

  //move the index by 2 to reach the castling characters
  index+=2; //start of castling bit

  std::cout << "A new board state is loaded!\n";
}

//determine type of piece based on char in fen string
ChessPiece* ChessBoard::pieceIdentifier(char fenChar){
  ChessPiece* ptr;

  Color pieceFenColor = getFenColor(fenChar);
  
  if (fenChar == 'p' || fenChar == 'P'){
    ptr = new Pawn(pieceFenColor);
   }
  else if (fenChar == 'n' || fenChar == 'N'){
    ptr = new Pawn(pieceFenColor);
    }
  else if (fenChar == 'b' || fenChar == 'B'){
    ptr = new Pawn(pieceFenColor);
  }
  else if (fenChar == 'r' || fenChar == 'R'){
    ptr = new Pawn(pieceFenColor);
  }
  else if (fenChar == 'q' || fenChar == 'Q'){
    ptr = new Pawn(pieceFenColor);
  }
  else if (fenChar == 'k' || fenChar == 'K'){
    ptr = new Pawn(pieceFenColor);
  }
  else {
    cerr << "Not a valid fen record character.\n";
    ptr = nullptr;
  }

  //ptr->setColor(fenChar);
  
  return ptr;
}

Color ChessBoard::getFenColor(char fenChar){
  if (fenChar >= 'B' && fenChar <= 'R'){
    cout << "TESTING GETCOLOR() - white" << endl;
    return white;
  }
  else {
    cout << "TESTING GETCOLOR() - black" << endl;
    return black;
  }
}


void ChessBoard::submitMove(const char* startingPosition, const char* moveToPosition){

  int startingRow, startingCol, moveToRow, moveToCol;

 //determine starting position on board
  startingCol = startingPosition[0] - 'A';
  startingRow = 7 - (startingPosition[1] - '1');

  //determine goal position to move piece to on board
  moveToCol = moveToPosition[0] - 'A';
  moveToRow = 7 - (moveToPosition[1] - '1');

  ChessPiece* pieceToMove = boardLayout[startingRow][startingCol];

  //check if starting spot on board has a nullptr (ie, no piece)
  if (pieceToMove == nullptr){
    cout << "TESTING SUBMITMOVE - spot is nullptr" << endl;
    return;
  }
  
  //override virtual method to determine if move is valid for that type of piece
  if (!pieceToMove->isValidMove(startingRow, startingCol, moveToRow, moveToCol)){ //notation means "if false"
    cout << "TESTING ISVALIDMOVE - not a valid move..." << endl;
    return;
  } 

  //now we know piece is valid, move is valid
  //PLACEHOLDER FOR OTHER CHECKS, LIKE CHECK ---------

    ChessPiece* pieceToTake = boardLayout[moveToRow][moveToCol];

  //check if there is a piece of the opposite color to be taken at that spot
  if (pieceToTake != nullptr && pieceToTake->getColor() == pieceToMove->getColor()){
    cout << "TESTING SUBMITMOVE - piecetotake is not valid" << endl;
    return;
  }

  //now we've done the checks. time to update the board
  //update board to store nullptr where piece used to be, and store piece data at new location
  boardLayout[startingRow][startingCol] = nullptr;
  boardLayout[moveToRow][moveToCol] = pieceToMove;
  cout << pieceToMove->getColor() << "'s " << pieceToMove->getName() << " moves from " << startingPosition << " to " << moveToPosition;

  
  if (pieceToTake != nullptr){
    cout << " taking " << pieceToTake->getColor() << "'s " << pieceToTake->getName();
    delete pieceToTake;
  } 

  cout << endl;

} 


/*bool isPositionOpen() {
  int rank;
  int file;
  if (boardLayout[row][col] == NULL){
    //code
  }
  else
  //cout << color, piece << " cannot move to " << position << "!" << endl;
//}*/
